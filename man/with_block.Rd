% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/with_block.R
\name{with_block}
\alias{with_block}
\title{Turn a function into one that accepts a block, ruby-style.}
\usage{
with_block(fn)
}
\arguments{
\item{fn}{function. The function to convert into a block-accepting function.
When calling \code{yield()} from within the function, the block will be
substituted instead.}
}
\value{
a function with one additional argument called \code{"_block"} 
   that will store an expression to evaluate using \code{yield()} from
   within the body of \code{fn}. Additional "arguments" can be passed
   to \code{yield} which will be injected into the lexical scope of
   the evaluation.
}
\description{
Turn a function into one that accepts a block, ruby-style.
}
\examples{
blocked_fn <- with_block(function(x, y) x + y + yield())
stopifnot(identical(blocked_fn(1, 2, { 3 + 4 }), 10))

assign_names <- with_block(function(x) {
 setNames(x, vapply(x, function(y) paste0("element_", yield(name = y)), character(1)))
})
stopifnot(identical(assign_names(letters[1:5], { toupper(name) }),
  list(element_A = 'a', element_B = 'b', element_C = 'c',
    element_D = 'd', element_E = 'e')))

maybe_block <- with_block(function() { list(1, if (block_given()) yield()) })
stopifnot(identical(maybe_block(2), list(1, 2)) && identical(maybe_block(), list(1)))
}

